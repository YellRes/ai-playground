# GraphRecursionError 问题分析与解决

## 问题现象

运行 `python index.py pdf` 时出现以下错误：

```
langgraph.errors.GraphRecursionError: Recursion limit of 25 reached without hitting a stop condition.
```

## 问题原因

### 1. **Agent 陷入工具调用循环**

LangGraph 的 ReAct Agent 在执行任务时会不断调用工具，每次调用算作一次"递归"。默认递归限制是 25 次。

当 Agent 在 25 次迭代内无法完成任务或不知道何时停止时，就会触发此错误。

### 2. **任务过于复杂和模糊**

原始查询：`"请加载并分析这个PDF文件：{pdf_path}"`

这个查询包含了两个动作：
- **加载** PDF
- **分析** PDF

"分析"是一个非常开放的概念，Agent 可能会：
1. 调用 `load_financial_pdf` 加载文件
2. 调用 `search_financial_info` 搜索信息
3. 调用 `extract_financial_data` 提取数据
4. 调用 `analyze_profitability` 分析盈利能力
5. 调用 `analyze_liquidity` 分析流动性
6. 调用 `analyze_leverage` 分析杠杆
7. 再次调用 `search_financial_info` 寻找更多信息
8. ... 循环往复

### 3. **系统提示不够明确**

原始系统提示鼓励 Agent "主动使用工具进行分析"，但没有明确说明何时应该停止。这导致 Agent 认为应该尽可能多地使用工具来提供完整的分析。

### 4. **PDF 文件较大**

- 143 页
- 336 个文本块
- 大量财务数据

这可能让 Agent 认为需要多次检索和分析才能给出满意的答案。

## 解决方案

### 方案 1：增加递归限制（已实施）✅

```python
config = {
    "configurable": {"thread_id": thread_id},
    "recursion_limit": 50  # 从默认的 25 增加到 50
}
```

**优点**：
- 简单直接
- 允许 Agent 执行更多步骤

**缺点**：
- 治标不治本
- 可能只是延迟问题出现

### 方案 2：优化系统提示（已实施）✅

添加了明确的停止规则：

```python
⚠️ 重要规则：
- 只执行用户明确要求的任务
- 如果用户只要求"加载PDF"，加载完成后就停止，不要自动分析
- 如果用户只要求"提取数据"，提取完成后就停止
- 避免过度使用工具，每个任务只调用必要的工具
```

**优点**：
- 根本性解决问题
- 减少不必要的工具调用
- 提高响应速度

### 方案 3：拆分复杂查询（已实施）✅

将原来的复杂查询：
```python
"请加载并分析这个PDF文件：{pdf_path}"
```

修改为更简单明确的查询：
```python
"请加载这个PDF文件：{pdf_path}"  # 只要求加载
```

**优点**：
- 每个查询任务明确
- 减少 Agent 的决策负担
- 更容易控制执行流程

## 最佳实践建议

### 1. **使用明确的任务描述**

❌ 不好：
```python
"分析这个财务报表"  # 太模糊
```

✅ 好：
```python
"从PDF中提取营业收入和净利润数据"  # 具体明确
```

### 2. **设置合理的递归限制**

```python
# 简单任务（1-3个工具调用）
recursion_limit: 10

# 中等任务（3-5个工具调用）
recursion_limit: 25 (默认值)

# 复杂任务（5-10个工具调用）
recursion_limit: 50

# 非常复杂的任务（10+个工具调用）
recursion_limit: 100
```

### 3. **在系统提示中明确停止条件**

```python
system_prompt = """
...
重要：完成用户要求的任务后，立即给出结论，不要进行额外的分析。
"""
```

### 4. **监控 Agent 执行过程**

可以添加调试输出来查看 Agent 的工具调用链：

```python
result = agent.invoke(
    {"messages": messages},
    config=config
)

# 查看所有消息，了解工具调用过程
for msg in result['messages']:
    print(f"{msg.type}: {msg.content}")
```

### 5. **考虑使用流式输出**

```python
for chunk in agent.stream({"messages": messages}, config=config):
    print(chunk)  # 实时查看执行过程
```

## 验证修复

修改后，再次运行：

```bash
python index.py pdf
```

应该能够成功执行，并且：
- 第一个查询只加载 PDF
- 第二个查询只提取数据
- 第三个查询基于已提取的数据进行分析

## 进一步优化建议

### 1. **添加执行监控**

```python
def main_with_pdf_debug():
    """带调试信息的PDF分析"""
    for i, query in enumerate(test_queries, 1):
        print(f"\n🔍 执行查询 {i}...")
        
        start_time = time.time()
        result = agent.invoke({"messages": messages}, config=config)
        end_time = time.time()
        
        print(f"⏱️  执行时间: {end_time - start_time:.2f}秒")
        print(f"🔧 工具调用次数: {len([m for m in result['messages'] if m.type == 'tool'])}次")
```

### 2. **使用更智能的 Agent**

考虑升级模型或调整 temperature：

```python
llm = ChatOpenAI(
    model="deepseek-chat",
    temperature=0,  # 降低随机性，提高决策一致性
)
```

### 3. **实现工具调用限制**

在关键工具中添加调用次数限制：

```python
# 全局计数器
tool_call_count = {"search": 0}

@tool
def search_financial_info(query: str) -> str:
    tool_call_count["search"] += 1
    if tool_call_count["search"] > 5:
        return "已达到搜索次数限制，请基于已有信息回答"
    # ... 正常执行
```

## 总结

这个问题的核心是 **Agent 的工具调用控制**。通过：
1. ✅ 增加递归限制（应急）
2. ✅ 优化系统提示（根本）
3. ✅ 简化查询任务（预防）

三管齐下，应该能够彻底解决这个问题。

如果问题仍然存在，建议：
- 启用调试模式查看具体的工具调用链
- 考虑使用更简单的工具集
- 或者切换到更智能的 LLM 模型

